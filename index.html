<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Controlled Sun</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; transform: scaleX(-1); }
        video { position: absolute; top: 0; left: 0; z-index: 0; opacity: 0; pointer-events: none; transform: scaleX(-1); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; z-index: 10; font-size: 20px; text-align: center;
        }
    </style>
    <!-- Import Three.js and MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Magic...<br><small>Please allow camera access</small></div>
    <video id="input_video" playsinline></video>

    <script>
        // --- CONFIGURATION ---
        const VIDEO_WIDTH = 1280;
        const VIDEO_HEIGHT = 720;
        
        // --- 1. THREE.JS SETUP (The 3D World) ---
        const scene = new THREE.Scene();
        
        // Camera setup to match 2D screen roughly
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // --- 2. CREATE THE SUN OBJECT ---
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00, 
            transparent: true, 
            opacity: 0.9 
        });
        const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
        
        // Add a glow effect (larger sphere behind)
        const glowGeometry = new THREE.SphereGeometry(3.5, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff4400, 
            transparent: true, 
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        sunMesh.add(glowMesh); // Attach glow to sun
        
        // Light emitting from sun
        const sunLight = new THREE.PointLight(0xffaa00, 2, 50);
        sunMesh.add(sunLight);

        scene.add(sunMesh);
        sunMesh.visible = false; // Hidden by default

        // --- 3. PARTICLE SYSTEM (Explosion) ---
        const particleCount = 200;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = []; 

        for(let i=0; i<particleCount; i++) {
            positions[i*3] = 0; positions[i*3+1] = 0; positions[i*3+2] = 0;
            velocities.push(new THREE.Vector3());
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0xffaa00,
            size: 0.8,
            transparent: true,
            opacity: 0
        });
        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        let explosionActive = false;

        function triggerExplosion(pos) {
            explosionActive = true;
            particlesMaterial.opacity = 1;
            
            const positions = particleSystem.geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                // Reset positions to sun center
                positions[i*3] = pos.x;
                positions[i*3+1] = pos.y;
                positions[i*3+2] = pos.z;

                // Random explosion velocity
                velocities[i].set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- 4. MEDIAPIPE HANDS LOGIC ---
        const videoElement = document.getElementById('input_video');
        let isHandClosed = false;
        let isHandDetected = false;

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Calculate Palm Center (Average of wrist and middle finger base)
                const wrist = landmarks[0];
                const middleFingerBase = landmarks[9];
                
                // Convert normalized coordinates (0-1) to Three.js World Coordinates
                // Note: We create a projection mapping based on camera Z depth
                const x = (0.5 - wrist.x) * 30; // 30 is a scaling factor based on FOV
                const y = (0.5 - wrist.y) * 20; // Invert Y
                const z = 0; 

                // 2. Detect Gesture (Open vs Closed)
                // We check the distance between the Wrist (0) and the Middle Finger Tip (12)
                const tipY = landmarks[12].y;
                const wristY = landmarks[0].y;
                const distance = Math.sqrt(
                    Math.pow(landmarks[12].x - landmarks[0].x, 2) + 
                    Math.pow(landmarks[12].y - landmarks[0].y, 2)
                );

                // Thresholds usually need tuning. 
                // < 0.25 usually means fingers are curled in (Fist)
                // > 0.35 usually means fingers are extended (Palm)
                const wasClosed = isHandClosed;
                isHandClosed = distance < 0.25;

                // LOGIC STATE MACHINE
                if (!isHandClosed) {
                    // HAND OPEN: Show Sun
                    sunMesh.visible = true;
                    // Interpolate position for smoothness
                    sunMesh.position.x += (x - sunMesh.position.x) * 0.2;
                    sunMesh.position.y += (y - sunMesh.position.y) * 0.2;
                    sunMesh.position.z = z;
                    
                    // Pulse effect
                    const time = Date.now() * 0.005;
                    const scale = 1 + Math.sin(time) * 0.1;
                    sunMesh.scale.set(scale, scale, scale);

                } else if (isHandClosed && !wasClosed && sunMesh.visible) {
                    // JUST CLOSED FIST: Explode!
                    sunMesh.visible = false;
                    triggerExplosion(sunMesh.position);
                }

            } else {
                isHandDetected = false;
                // Optionally hide sun if hand leaves frame, but let's keep it until explosion
                if(!explosionActive) sunMesh.visible = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: VIDEO_WIDTH,
            height: VIDEO_HEIGHT
        });
        cameraUtils.start();

        // --- 5. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Animate Explosion
            if (explosionActive) {
                const positions = particleSystem.geometry.attributes.position.array;
                let activeParticles = false;

                for (let i = 0; i < particleCount; i++) {
                    positions[i*3] += velocities[i].x;
                    positions[i*3+1] += velocities[i].y;
                    positions[i*3+2] += velocities[i].z;

                    // Apply drag/gravity
                    velocities[i].multiplyScalar(0.95); // Drag

                    // Check if particles are still moving meaningfully
                    if (Math.abs(velocities[i].x) > 0.01) activeParticles = true;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                
                // Fade out
                particlesMaterial.opacity -= 0.02;
                if (particlesMaterial.opacity <= 0) {
                    explosionActive = false;
                    particlesMaterial.opacity = 0;
                }
            }

            // Rotate Sun Glow
            glowMesh.rotation.z += 0.01;
            glowMesh.rotation.x += 0.01;

            renderer.render(scene, camera);
        }
        
        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
